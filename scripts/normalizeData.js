#!/usr/bin/env node

/**
 * normalizeData.js
 * Lee src/data/bible-complete.json (generado por parseHTM.js)
 * y crea src/data/bible.json con la estructura:
 * {
 *   version, language,
 *   books: [{ id, name, testament, chapters: [{ number, verses: [{ number, text }] }] }],
 *   totals: { chapters, verses }
 * }
 */

import fs from 'fs';
import path from 'path';

const INPUT = path.join(process.cwd(), 'src', 'data', 'bible-complete.json');
const OUTPUT = path.join(process.cwd(), 'src', 'data', 'bible.json');

if (!fs.existsSync(INPUT)) {
  console.error(`Input file not found: ${INPUT}`);
  process.exit(1);
}

const raw = JSON.parse(fs.readFileSync(INPUT, 'utf8'));
// try to load external refs map if exists (generated by scripts/extractRefs.js)
const REFS_PATH = path.join(process.cwd(), 'src', 'data', 'verse-refs.json');
let refsMap = {};
if (fs.existsSync(REFS_PATH)) {
  try {
    refsMap = JSON.parse(fs.readFileSync(REFS_PATH, 'utf8'));
    console.log(`ℹ️ Cargadas ${Object.keys(refsMap).length} referencias desde ${REFS_PATH}`);
  } catch (err) {
    console.warn('⚠ Error leyendo refs file:', err.message);
    refsMap = {};
  }
}

// Lista simplificada de libros del Antiguo Testamento para detectar testamento
const OLD_TESTAMENT_KEYWORDS = [
  'Génesis','Genesis','Éxodo','Exodo','Levítico','Levitico','Números','Numeros','Deuteronomio','Josué',
  'Jueces','Samuel','Reyes','Crónicas','Cronicas','Esdras','Nehemías','Nehemias','Ester','Job','Salmos','Proverbios',
  'Eclesiastés','Eclesiastes','Isaías','Isaias','Jeremías','Jeremias','Lamentaciones','Ezequiel','Ezequiel','Daniel',
  'Oseas','Joel','Amós','Amos','Abdías','Jonás','Jonas','Miqueas','Nahúm','Habacuc','Sofonías','Ageo','Zacarías','Zacarias','Malaquias','Salmos'
];

function detectTestament(bookTitle) {
  if (!bookTitle) return 'old';
  const t = OLD_TESTAMENT_KEYWORDS.find(k => bookTitle.includes(k));
  return t ? 'old' : 'new';
}

// Normalize into testamento -> libro -> capítulo
const testamentsMap = new Map();
let totalChapters = 0;
let totalVerses = 0;

function testamentLabel(t) {
  if (!t) return 'Desconocido';
  if (t === 'old') return 'Antiguo Testamento';
  if (t === 'new') return 'Nuevo Testamento';
  return t;
}

raw.chapters.forEach((ch) => {
  const fileName = ch.file || '';
  const bookTitle = ch.bookTitle || 'Sin libro';
  const chapterNumber = ch.chapterNumber || 0;
  const verses = Array.isArray(ch.verses) ? ch.verses : [];
  const testamentKey = ch.testament || detectTestament(bookTitle) || 'old';
  const tLabel = testamentLabel(testamentKey);

  if (!testamentsMap.has(tLabel)) {
    testamentsMap.set(tLabel, {
      name: tLabel,
      key: testamentKey,
      books: new Map(),
    });
  }

  const testament = testamentsMap.get(tLabel);
  const bookId = bookTitle.toLowerCase().replace(/[^a-z0-9]+/g, '_').replace(/^_+|_+$/g, '') || 'unknown';

  if (!testament.books.has(bookId)) {
    // use a map to allow deduplication by chapter number
    testament.books.set(bookId, {
      id: bookId,
      name: bookTitle,
      chaptersMap: new Map(),
    });
  }

  const book = testament.books.get(bookId);
  const chapKey = (chapterNumber === null || chapterNumber === undefined) ? '__null' : String(chapterNumber);

  const verseObjs = verses.map(v => {
    const base = { number: v.number, text: v.text };
    const refKey = fileName ? `${fileName}:${v.number}` : null;
    if (refKey && refsMap[refKey]) base.refs = refsMap[refKey];
    return base;
  });

  // Deduplication rule: if a chapter number already exists, keep the entry whose file name is first alphabetically
  if (book.chaptersMap.has(chapKey)) {
    const existing = book.chaptersMap.get(chapKey);
    const keep = (fileName && existing.file)
      ? (fileName.localeCompare(existing.file) < 0 ? { number: chapterNumber, file: fileName, verses: verseObjs } : existing)
      : existing;
    book.chaptersMap.set(chapKey, keep);
  } else {
    book.chaptersMap.set(chapKey, { number: chapterNumber, file: fileName, verses: verseObjs });
  }

  totalChapters += 1;
  totalVerses += verses.length;
});

// Convert maps to arrays and sort chapters
const testaments = [];
for (const t of testamentsMap.values()) {
  const books = [];
  for (const b of t.books.values()) {
    // convert chaptersMap -> chapters array, sort by numeric chapter number (nulls at end)
    const chapters = [];
    if (b.chaptersMap) {
      for (const entry of b.chaptersMap.values()) chapters.push(entry);
      chapters.sort((a, b) => {
        const an = (a.number === null || a.number === undefined) ? Number.POSITIVE_INFINITY : a.number;
        const bn = (b.number === null || b.number === undefined) ? Number.POSITIVE_INFINITY : b.number;
        return an - bn;
      });
    }
    books.push({ id: b.id, name: b.name, chapters });
  }
  // If this is the Nuevo Testamento, try to order books in canonical NT order
  if (/nuevo/i.test(String(t.key || '')) || /nuevo/i.test(String(t.name || ''))) {
    const NEW_TESTAMENT_ORDER = [
      'Mateo','Marcos','Lucas','Juan','Hechos','Romanos','1 Corintios','2 Corintios','Gálatas','Efesios','Filipenses','Colosenses',
      '1 Tesalonicenses','2 Tesalonicenses','1 Timoteo','2 Timoteo','Tito','Filemón','Hebreos','Santiago','1 Pedro','2 Pedro',
      '1 Juan','2 Juan','3 Juan','Judas','Apocalipsis','Apocalipsis'
    ];

    // Normalize helper: remove diacritics, collapse non-alphanumerics and map ordinals
    const normalize = (s) => {
      if (!s) return '';
      // map spanish ordinals to numbers to handle 'Primera', 'Segunda', 'Tercera'
      let out = s.toLowerCase();
      out = out.replace(/primera/g, '1');
      out = out.replace(/primero/g, '1');
      out = out.replace(/segunda/g, '2');
      out = out.replace(/segundo/g, '2');
      out = out.replace(/tercera/g, '3');
      out = out.replace(/tercero/g, '3');
      // remove diacritics
      out = out.normalize('NFD').replace(/\p{Diacritic}/gu, '');
    // remove common honorifics like 'san', 'santo', 'santa' to normalize names like 'san juan' -> 'juan'
    out = out.replace(/\b(san|santo|santa)\b/g, ' ');
    // remove simple stopwords/prepositions and common words like 'carta' to improve matching
    out = out.replace(/\b(de|del|la|el|los|las|a|al|segun|carta)\b/g, ' ');
      // collapse non-alphanumeric to spaces
      out = out.replace(/[^a-z0-9]+/g, ' ').trim();
      return out;
    };

    const normalizedCandidates = NEW_TESTAMENT_ORDER.map(c => normalize(c));
    const numericCandidateIndices = [];
    const nonNumericCandidateIndices = [];
    normalizedCandidates.forEach((nc, idx) => {
      if (/^\d/.test(nc)) numericCandidateIndices.push(idx);
      else nonNumericCandidateIndices.push(idx);
    });

    const findIndex = (name) => {
      if (!name) return -1;
      const ln = normalize(name);

      // prefer exact/whole-word matches of numeric+name (e.g., '1 juan')
      for (let i = 0; i < normalizedCandidates.length; i++) {
        const cand = normalizedCandidates[i];
        if (ln === cand) return i;
      }

      // then prefer matches for numeric candidates first (e.g. '1 juan')
      for (let j = 0; j < numericCandidateIndices.length; j++) {
        const i = numericCandidateIndices[j];
        const cand = normalizedCandidates[i];
        if (ln.includes(cand)) return i;
      }
      // then non-numeric candidates (e.g. 'juan', 'mateo')
      for (let j = 0; j < nonNumericCandidateIndices.length; j++) {
        const i = nonNumericCandidateIndices[j];
        const cand = normalizedCandidates[i];
        if (ln.includes(cand)) return i;
      }

      // finally, try partial reverse
      for (let i = 0; i < normalizedCandidates.length; i++) {
        const cand = normalizedCandidates[i];
        if (cand.includes(ln)) return i;
      }

      return -1;
    };

    // stable sort: keep relative order for unknowns
    books.sort((a, b) => {
      const ia = findIndex(a.name);
      const ib = findIndex(b.name);
      if (ia === -1 && ib === -1) return 0; // keep original order
      if (ia === -1) return 1;
      if (ib === -1) return -1;
      return ia - ib;
    });
  }

  testaments.push({ name: t.name, key: t.key, books });
}

const output = {
  version: raw.version || 'Biblia (normalizada)',
  language: raw.language || 'es',
  testaments,
  totals: { chapters: totalChapters, verses: totalVerses }
};

fs.writeFileSync(OUTPUT, JSON.stringify(output, null, 2), 'utf8');
console.log(`✅ Normalización completada. ${testaments.reduce((s,t)=>s + t.books.length,0)} libros, ${totalChapters} capítulos, ${totalVerses} versículos.`);
console.log(`✳️ Archivo guardado en ${OUTPUT}`);
